% Globally clean conflicts, taking into account which trajectories are real
%
% Input:
%   conflicts : cell array with conflicting clusterIDs
%   trajs : structure array such as generated by clusters2trajs
%
% Outputs:
%   updated versions of the inputs
%
% (c) Simon Grosse-Holz, 2020

function [conflicts, trajs] = clean_conflicts(conflicts, trajs)
    % Add all the trajectories that have duplicate times as having a
    % conflict. Note: this makes it possible for there to be a conflict
    % involving only one trajectory
    conflicts = [conflicts, num2cell(duplicate_times(trajs))];
    
    % First thing: merge conflicts, if they have a common trajectory. This
    % has to happen asap, bc there are empty clusters providing linking for
    % conflicts, but those would be the first we kick out when doing
    % anything (see below).
    conflict_ids = unique([conflicts{:}]);
    for i = 1:length(conflict_ids)
        ind = cellfun(@(c) any(c == conflict_ids(i)), conflicts);
        if sum(ind) > 1
            conflicts = [conflicts(~ind), unique([conflicts{ind}])];
        end
    end
    
    % If there is an invalid (i.e. empty) trajectory participating in a
    % conflict, kick it out. If that resolves the conflict, link the
    % trajectories
    valid_trajs = [trajs.id];
    confKill = zeros(size(conflicts));
    for i = 1:length(conflicts)
        curconf = conflicts{i};
        curconf = curconf(ismember(curconf, valid_trajs));
        if length(curconf) > 2
            conflicts{i} = curconf;
        else
            confKill(i) = true;
            if length(curconf) == 2
                [conflicts, trajs] = try_relinking(conflicts, trajs, curconf(1), curconf(2));
            end
        end
    end
    conflicts = conflicts(~confKill);
end
